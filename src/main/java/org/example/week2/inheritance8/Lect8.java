package org.example.week2.inheritance8;

public class Lect8 {
    public static void main(String[] args) {

        ///  학습 키워드
        //- [ ]  상속 - 코드를 재사용하고 확장하는 객체지향 개념
        //- [ ]  super - 부모인스턴스를 가르키는 키워드
        //- [ ]  오버라이딩 - 상속받은 메서드를 자식 클래스에서 재정의하는 방법
        //- [ ]  추상클래스 - 공통 기능을 제공하면서 하위 클래스에 특정 메서드 구현을 강제하기 위해 사용

        ///  상속(Inheritance) 이란?
        //- 클래스간의 관계를 `부모(상위)`, `자식(하위)` 로 바라보는 개념입니다.
        //- 이 구조를 통해 상속에서는 **`재사용성`, `확장`** 이 가능합니다.(중요한 키워드 입니다.)
        //
        //    → 물려받은 속성과 기능은 자식 클래스에서 **재사용**할 수도 있고, **확장**할수도 있습니다.
        //
        //- **`extends`  키워드를 사용해서 상속관계**를 구현합니다.
        //- 부모의 속성과 기능을 자식이 자연스럽게 물려받는다라고 생각하면 이해하기 쉽습니다.
        //- 상속을 통해 코드 중복을 줄이고 유지보수성을 높일 수 있습니다.
        //- 추상화, 다형성을 구현하는데 잘 활용됩니다. 다음 수업에서 더 자세히 다룰 예정입니다.

        ///  재사용성
        //**상속의 첫 번째 장점 - 재사용성을 살펴봅시다.**
        //- 상속의 장점은 **부모 클래스의 내용을 물려받아 그대로 `재사용`**할 수 있습니다.

        Child child = new Child();
        System.out.println("가문이름 = " + child.familyName);   // ✅ 부모의 속성을 물려받아 사용
        System.out.println("명예 = " + child.honor);           // ✅ 부모의 속성을 물려받아 사용
        child.introduceFamily(); // ✅ 부모의 메서드를 물려받아 사용

        /// super - 부모 인스턴스
        // `super` 는 부모클래스의 멤버(변수, 메서드)에 접근할 때 사용하는 키워드입니다.
        //- 자식 클래스에서 부모의 변수나 메서드를 명확하게 호출할 때 사용합니다.

        child.superTest();

        ///  super() - 부모 인스턴스의 생성자
        //**부모와 자식간의 생성 순서를 알아봅시다.**
        //- 부모가 먼저 생성되고 자식이 생성됩니다.
        //- 부모가 먼저 생성되어야 하므로 `super()`는 항상 생성자의 첫 줄에 위치해야 합니다.



        ///  확장
        //**상속의 두 번째 장점 - 확장**
        //- **부모클래스의 기능을 유지하면서 자식클래스에서 기능을 확장**할 수 있습니다.
        //- 자식클래스에서 새로운 메서드를 추가하면 됩니다.

        // ✅ 부모에는 없지만 자식에만 있는 기능
        child.showSocialMedia();

        /// 재정의 - 메서드 오버라이딩(overriding)
        //**오버라이딩을 통해 부모클래스의 기능을 재정의할 수 있습니다.**
        //- 부모 메서드를 자식 클래스에서 변경하여 재정의하는 것을 의미합니다.
        //    - 오버라이드된 메서드에는 `@Override`  키워드를 붙이는 것을 권장합니다.(없어도 동작합니다.)
        //    - `@Override` 를 붙이면 컴파일러가 부모 클래스에 동일한 메서드가 없다고 경고를 줘서 실수를 방지할 수 있습니다.
        //- 메서드 이름, 매개변수, 반환타입이 완전히 동일해야합니다.
        //- 접근 제어자는 부모보다 더 강한 수준으로만 변경 가능합니다.


        ///  추상클래스
        //공통 기능을 제공하면서 하위 클래스에 특정 메서드 구현을 강제하기 위해 사용됩니다.
        //
        //- 객체를 생성할 목적이 아니라 “설계도” 역할을 할때 적합합니다.
        //- `abstract` 키워드로 클래스를 선언하면 `추상클래스`입니다.
        //- `abstract` 키워드로 메서드를 선언하면 자식클래스에서 강제로 구현해야합니다.
        //- **추상클래스로 객체를 생성할 수 없습니다.**
        //- 일반 클래스처럼 변수와 메서드를 가질 수 있습니다.


        ///  추상클래스 와 인터페이스의 차이점
        //- 상속이 계층적 구조를 선언하기 적합합니다.
        //- 인터페이스는 표준을 제공하는 데 적합합니다.
        //- 인터페이스는 인스턴스 변수를 선언할 수 없습니다.
        //- 계층적 구조를 표현하면서 공통 속성과 기능을 재사용할 때 추상클래스를 사용하는것이 적합합니다.
    }
}

